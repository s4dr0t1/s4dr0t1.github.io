"use strict";(self.webpackChunkrohitdhill_me=self.webpackChunkrohitdhill_me||[]).push([[546],{4137:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var m=n.createContext({}),l=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(m.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),u=r,h=d["".concat(m,".").concat(u)]||d[u]||c[u]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var m in t)hasOwnProperty.call(t,m)&&(s[m]=t[m]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5684:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return m},metadata:function(){return l},assets:function(){return p},toc:function(){return c},default:function(){return u}});var n=a(7462),r=a(3366),i=(a(7294),a(4137)),o=["components"],s={title:"Intermediate Representation (IR)",id:"Intermediate-Representation",pagination_label:"Understanding Intermediate Representation",sidebar_label:"Intermediate Representation (IR)"},m=void 0,l={unversionedId:"programming/Intermediate-Representation",id:"programming/Intermediate-Representation",title:"Intermediate Representation (IR)",description:"Understanding different types of Intermediate Representation (IR) and compiler frameworks such as LLVM",source:"@site/docs/programming/03. Compiler frameworks.md",sourceDirName:"programming",slug:"/programming/Intermediate-Representation",permalink:"/docs/programming/Intermediate-Representation",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Intermediate Representation (IR)",id:"Intermediate-Representation",pagination_label:"Understanding Intermediate Representation",sidebar_label:"Intermediate Representation (IR)"},sidebar:"tutorialSidebar",previous:{title:"Understand the process of how execution of intermediate/ interpreted programs takes place",permalink:"/docs/programming/Program Execution/interediate-interpreted-execution"},next:{title:"Understanding how decompilers and disassemblers work under the hood",permalink:"/docs/programming/decompilers-disassemblers"}},p={},c=[{value:"LLVM",id:"llvm",level:2},{value:"Introduction",id:"introduction",level:3},{value:"How did LLVM change the game?",id:"how-did-llvm-change-the-game",level:3},{value:"How does it all work?",id:"how-does-it-all-work",level:3},{value:"Credits/ References",id:"credits-references",level:2}],d={toc:c};function u(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Understanding different types of Intermediate Representation (IR) and compiler frameworks such as LLVM")),(0,i.kt)("h2",{id:"llvm"},"LLVM"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It's an umbrella term for a lot of parts related to the developer tool-chain technologies, such as debuggers, compilers, code optimisation tools, internal representations etc."),(0,i.kt)("li",{parentName:"ul"},"MLIR is another compiler infrastructure project, similar to LLVM. The difference is that LLVM has an IR that is fixed in nature, but MLIR lets us define our own IR, giving us much more flexibility.")),(0,i.kt)("h3",{id:"how-did-llvm-change-the-game"},"How did LLVM change the game?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Before LLVM came into the picture, steps related to compilation (parsing, lexical analysis, optimisation, conversion, semantic analysis, intermediate code generation etc) were monolithic in nature, and for any given language, we had this structure. If we wanted to make a new language, we had to design it from scratch. If we had ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"M")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"M")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M")))))," languages and ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"N")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," targets, we would have needed ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"M"),(0,i.kt)("mo",{parentName:"mrow"},"\u2217"),(0,i.kt)("mi",{parentName:"mrow"},"N")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"M*N")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2217"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," compilers."),(0,i.kt)("li",{parentName:"ul"},"With LLVM, the monolithic structure can be broken down into independent parts where one research can fully devote his time to do what he\u2019s best at.")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"Before and after LLVM",src:a(8482).Z,width:"2872",height:"1209"})),(0,i.kt)("h3",{id:"how-does-it-all-work"},"How does it all work?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The compiler front-end is used to convert the code into LLVM IR, middle-end of the compiler is used for LLVM IR optimisation (done by opt) and the compiler back-end is used for conversion of the optimised LLVM IR into machine code based on different instruction sets. "),(0,i.kt)("li",{parentName:"ul"},"All the aforementioned parts are decoupled from one another making the framework extremely modular in nature"),(0,i.kt)("li",{parentName:"ul"},"If we\u2019re designing a new programming language, we only have to design the compiler front-end for it, making it output LLVM IR, and the framework can handle the rest, and we can port it for different architecture."),(0,i.kt)("li",{parentName:"ul"},"The compiler front-end deals with things such as preprocessing, lexical, syntax and semantic analysis and finally leads to the generation of IR (LLVM-IR)"),(0,i.kt)("li",{parentName:"ul"},"The compiler middle end deals with optimizing the LLVM-IR"),(0,i.kt)("li",{parentName:"ul"},"The compiler back end is used to convert the optimised LLVM-IR into ISA-specific code")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"How LLVM works?",src:a(5220).Z,width:"4320",height:"1146"})),(0,i.kt)("h2",{id:"credits-references"},"Credits/ References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=A7I0497Up0c"},"YouTube: Introduction to Compilers and Stages of Compilation talk at LLVM Bangalore by Ashutosh Pandey and Shraiysh Vaishay")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=a5-WaD8VV38"},"YouTube: A Brief Introduction to LLVM by Morgan Wilde")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=J5xExRGaIIY"},"YouTube: 2019 LLVM Developers\u2019 Meeting: E. Christopher & J. Doerfert \u201cIntroduction to LLVM\u201d"))))}u.isMDXComponent=!0},8482:function(e,t,a){t.Z=a.p+"assets/images/llvm-monolith-7e3b2bcfc328028e7ffa7104d68f0a6d.png"},5220:function(e,t,a){t.Z=a.p+"assets/images/llvm-dc9e5ece720e542b29bea807df3f46f6.png"}}]);