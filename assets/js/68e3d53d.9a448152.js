"use strict";(self.webpackChunkrohitdhill_me=self.webpackChunkrohitdhill_me||[]).push([[230],{4137:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=i,h=p["".concat(l,".").concat(u)]||p[u]||d[u]||a;return n?r.createElement(h,o(o({ref:t},m),{},{components:n})):r.createElement(h,o({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8836:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return m},toc:function(){return d},default:function(){return u}});var r=n(7462),i=n(3366),a=(n(7294),n(4137)),o=["components"],s={title:"Decompilers and Disassemblers",id:"decompilers-disassemblers",pagination_label:"Understanding how decompilers and disassemblers work under the hood",sidebar_label:"Decompilers and Disassemblers"},l=void 0,c={unversionedId:"programming/decompilers-disassemblers",id:"programming/decompilers-disassemblers",title:"Decompilers and Disassemblers",description:"Understanding how decompilers work under the hood",source:"@site/docs/programming/04. Decompilers.md",sourceDirName:"programming",slug:"/programming/decompilers-disassemblers",permalink:"/docs/programming/decompilers-disassemblers",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Decompilers and Disassemblers",id:"decompilers-disassemblers",pagination_label:"Understanding how decompilers and disassemblers work under the hood",sidebar_label:"Decompilers and Disassemblers"},sidebar:"tutorialSidebar",previous:{title:"Understanding Intermediate Representation",permalink:"/docs/programming/Intermediate-Representation"}},m={},d=[{value:"Binary Rewriting",id:"binary-rewriting",level:2},{value:"Disassemblers",id:"disassemblers",level:2},{value:"Decompiler",id:"decompiler",level:2},{value:"What is microcode?",id:"what-is-microcode",level:3},{value:"Decompilers",id:"decompilers",level:3},{value:"Credits/ Refereces",id:"credits-refereces",level:2}],p={toc:d};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Understanding how decompilers work under the hood")),(0,a.kt)("h2",{id:"binary-rewriting"},"Binary Rewriting"),(0,a.kt)("p",null,"Before Understanding how decompilers work, we must first the technique that they are based upon: Binary Rewriting"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In layman terms, Binary Rewriting is all about transforming a binary into another form of binary based on some input rules."),(0,a.kt)("li",{parentName:"ul"},"No source code is needed to perform this technique and is independent of the programming language used"),(0,a.kt)("li",{parentName:"ul"},"According to this technique, the binary gets translated into another form"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Example"),": IDA Pro")),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"It's a hot research topic, I probably don't know enough about it, so I suggest checking out the links mentioned ",(0,a.kt)("a",{parentName:"p",href:"#credits-refereces"},"here"),". I've tried to cover the basics so that when you hear these terms somewhere, you can instantly understand what these terms are all about and not just stand there with a blank mind."))),(0,a.kt)("h2",{id:"disassemblers"},"Disassemblers"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The object code is all in binary, a disassembler takes the binary and put it in human readable assembly"),(0,a.kt)("li",{parentName:"ul"},"It does so by resolving 1-1 mapping of opcodes and their assembly mnemonics, still the analysis is difficult, because the analyst will have to manually think about its higher level abstractions, making it incredibly error prone."),(0,a.kt)("li",{parentName:"ul"},"Example: ",(0,a.kt)("inlineCode",{parentName:"li"},"objdump"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"$ objdump -d ./a.out -M intel                                                                                                                            \n\n#A lot of stuff is hiddien for brevity\n./a.out:     file format elf64-x86-64                                                                                                                        \nDisassembly of section .init:                                                                                                                                \n0000000000001000 <_init>:                                                                                                                                    \n    1000:       f3 0f 1e fa             endbr64                                                                                                              \n    1004:       48 83 ec 08             sub    rsp,0x8                                                                                                       \n    1008:       48 8b 05 d9 2f 00 00    mov    rax,QWORD PTR [rip+0x2fd9]        # 3fe8 <__gmon_start__@Base>                                                \n    100f:       48 85 c0                test   rax,rax                                                                                                       \n    1012:       74 02                   je     1016 <_init+0x16>\n    1014:       ff d0                   call   rax\n    1016:       48 83 c4 08             add    rsp,0x8\n    101a:       c3                      ret    \n\nDisassembly of section .plt:\n\n0000000000001020 <printf@plt-0x10>:\n    1020:       ff 35 e2 2f 00 00       push   QWORD PTR [rip+0x2fe2]        # 4008 <_GLOBAL_OFFSET_TABLE_+0x8>\n    1026:       ff 25 e4 2f 00 00       jmp    QWORD PTR [rip+0x2fe4]        # 4010 <_GLOBAL_OFFSET_TABLE_+0x10>\n    102c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]\n\n0000000000001030 <printf@plt>:\n    1030:       ff 25 e2 2f 00 00       jmp    QWORD PTR [rip+0x2fe2]        # 4018 <printf@GLIBC_2.2.5>\n    1036:       68 00 00 00 00          push   0x0\n    103b:       e9 e0 ff ff ff          jmp    1020 <_init+0x20>\n")),(0,a.kt)("h2",{id:"decompiler"},"Decompiler"),(0,a.kt)("h3",{id:"what-is-microcode"},"What is microcode?"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Microcode is an intermediate language like LLVM IR, MLIR etc. It was named so, because one micro-instruction only does a single thing (reduced-instruction-set), and it has a very small number of instructions."),(0,a.kt)("li",{parentName:"ul"},"It helps us to get rid of the complexity of processor assembly instructions and the complexity involved such as segment registers and the likes."),(0,a.kt)("li",{parentName:"ul"},"IR makes our decompiler very portable, and writing a decompiler without any intermediate language is a huge waste of time. We can write tools to convert different binaries to the same IR, and then write a back-end to convert that IR into some other form (the code in the case of decompilers). When adding support for new architectures, we just have to write the code to convert it to the IR, and the back-end will handle the rest.")),(0,a.kt)("h3",{id:"decompilers"},"Decompilers"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A decompiler tries to do the reverse of what a compiler does, viz. trying to recreate the source code from the binary")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x86 binary\u2502    \u2502PowerPC binary\u2502 \u2502ARM binary\u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n    \u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502architecture specific\u2502\u25c4\u2500\u2500\u2500\u2518\n             \u2502     front end       \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502 microcode \u2502              \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n               \u2502transform microcode\u2502         \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n             \u2502allocate local variables\u2502      \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502  Architecture\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502  Independent\n                 \u2502generate ctree\u2502            \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n                 \u2502beautify ctree\u2502            \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n                  \u2502print ctree\u2502         \u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Transformation of microcode is all about optimising the microcode (multiple passes), resolving memory references, analysing calls etc."),(0,a.kt)("li",{parentName:"ul"},"ctree is similar to AST that we study in compilers."),(0,a.kt)("li",{parentName:"ul"},"Compilers are privileged, they only accept a given set of rules and prints out an error message otherwise. Achieving an ideal decompiler on the on the other hand, is next to impossible, a lot of problems remain unsolvable. But we can try to cover most of the ground.")),(0,a.kt)("h2",{id:"credits-refereces"},"Credits/ Refereces"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://research.cs.wisc.edu/wisa/presentations/2003/0127/mihai/mihai.03.0127.pdf"},"General Purpose Binary Rewriting by Mihai Christodorescu")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=hLBlck1lTUs"},"CODE BLUE 2014: Ilfak Guilfanov - Keynote: The story of IDA Pro (YouTube)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=T-YkhNElvng"}," Decompiler Internals: Microcode by Ilfak Guilfanov (YouTube)")),(0,a.kt)("li",{parentName:"ul"},"Decompilers and beyond by Ilfak Guilfanov (YouTube): ",(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=xtzMXkA8mhQ"},"Link 1"),", ",(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=Uoa0T64RZ4w"},"Link 2"),", ",(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=zL_RGWbEkUk"},"Link 3"),", ",(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=O6af-o2tHAU"},"Link 4"))))}u.isMDXComponent=!0}}]);