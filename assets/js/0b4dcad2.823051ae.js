"use strict";(self.webpackChunkrohitdhill_me=self.webpackChunkrohitdhill_me||[]).push([[171],{4137:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),m=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=m(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=m(n),h=r,d=u["".concat(o,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(d,s(s({ref:t},c),{},{components:n})):a.createElement(d,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var m=2;m<i;m++)s[m]=n[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5394:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return m},assets:function(){return c},toc:function(){return p},default:function(){return h}});var a=n(7462),r=n(3366),i=(n(7294),n(4137)),s=["components"],l={title:"System Calls",id:"syscalls",pagination_label:"How does usermode applications perform privileged operations",sidebar_label:"System Calls"},o=void 0,m={unversionedId:"os/Kernel/syscalls",id:"os/Kernel/syscalls",title:"System Calls",description:"How usermode applications are able to interact with the Kernel",source:"@site/docs/os/2. Kernel/04. System Calls.md",sourceDirName:"os/2. Kernel",slug:"/os/Kernel/syscalls",permalink:"/docs/os/Kernel/syscalls",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"System Calls",id:"syscalls",pagination_label:"How does usermode applications perform privileged operations",sidebar_label:"System Calls"},sidebar:"tutorialSidebar",previous:{title:"Understanding interrupts",permalink:"/docs/os/Kernel/interrupts"},next:{title:"Why study programming?",permalink:"/docs/programming/pl-basics"}},c={},p=[{value:"Basics",id:"basics",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Interrupt",id:"interrupt",level:3},{value:"Understanding System Calls",id:"understanding-system-calls",level:2},{value:"Why do we need System Calls?",id:"why-do-we-need-system-calls",level:3},{value:"What is a System Call",id:"what-is-a-system-call",level:3},{value:"System Call Table and System Call Number",id:"system-call-table-and-system-call-number",level:2},{value:"Parameter Passing Techniques",id:"parameter-passing-techniques",level:2},{value:"System Call Wrappers",id:"system-call-wrappers",level:2},{value:"System Calls Behind The Scenes",id:"system-calls-behind-the-scenes",level:2},{value:"Invoking System Calls",id:"invoking-system-calls",level:3},{value:"What Actually Happens?",id:"what-actually-happens",level:3},{value:"Triggering System Calls",id:"triggering-system-calls",level:2},{value:"The Trap Mechanism - Legacy Method",id:"the-trap-mechanism---legacy-method",level:3},{value:"Fast System Call Mechanism",id:"fast-system-call-mechanism",level:3}],u={toc:p};function h(e){var t=e.components,l=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"How usermode applications are able to interact with the Kernel")),(0,i.kt)("h2",{id:"basics"},"Basics"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In the previous section, I mentioned about Ring-3 applications being able to access privileged stuff through some sort of mechanism. System Call act as a bridge b/w the two privilege ring, but before getting onto that, we must understand what an ",(0,i.kt)("strong",{parentName:"p"},"Interrupt")," is."),(0,i.kt)("h3",{id:"interrupt"},"Interrupt"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An interrupt is a signal that can be sent to the processor by the hardware/ software components, denoting there's an event which needs ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"immediate"))," attention"),(0,i.kt)("li",{parentName:"ul"},"The processor upon receiving the signal, calls an Interrupt Handler (Interrupt Service Routine - ISR) to deal with the urgent event."),(0,i.kt)("li",{parentName:"ul"},"Once the event has been dealt with, things go back to normal"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"),": When we hit a key on the keyboard, the response on the screen is instantaneous. How does this work? It's the magic of Interrupt signals")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"understanding-system-calls"},"Understanding System Calls"),(0,i.kt)("h3",{id:"why-do-we-need-system-calls"},"Why do we need System Calls?"),(0,i.kt)("p",null,"Since usermode programs can't perform privileged operations directly because they don't have the that level of privilege, they must request the Kernel (which runs in a privileged space) to do things for them such as Memory Management, Accessing I/O devices etc."),(0,i.kt)("h3",{id:"what-is-a-system-call"},"What is a System Call"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A system call is a piece of code defined to do a certain privileged operation, such as accessing a certain hardware, doing stuff with memory etc."),(0,i.kt)("li",{parentName:"ul"},"When it gets invoked, the CPU switches to Kernel Mode (Ring 1) and start executing the privileged function."),(0,i.kt)("li",{parentName:"ul"},"There are two types of System Calls: Synchronous and Asynchronous. In the former, the usermode process will wait for it to complete its operation, and in the latter, it'll not, and operations will continue as normal")),(0,i.kt)("h2",{id:"system-call-table-and-system-call-number"},"System Call Table and System Call Number"),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"System Call Table",src:n(5980).Z,width:"406",height:"193"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"There are a lot of system calls predefined to perform tasks in our Operating System, there must be some technique to let the Kernel know which system call it is we're trying to invoke."),(0,i.kt)("li",{parentName:"ul"},"System Call Table is used for this purpose, it's a mapping maintained by the OS which maps System Call numbers and their corresponding Kernel code viz. it is an array of pointers which point to the actual kernel code."),(0,i.kt)("li",{parentName:"ul"},"If we want to execute the ",(0,i.kt)("inlineCode",{parentName:"li"},"write()")," system call for example, we use its System Call Number as an identifier to let the Kernel know we want to invoke ",(0,i.kt)("inlineCode",{parentName:"li"},"write()"),".")),(0,i.kt)("h2",{id:"parameter-passing-techniques"},"Parameter Passing Techniques"),(0,i.kt)("p",null,"In C language, we have learnt that when calling functions, we need to provide arguments for it to let it know on whom we want to perform the operations upon"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="Random Code Snippet"',title:'"Random',Code:!0,'Snippet"':!0},'printf("%d", variable);\n// Here, stuff we have provided to printf() are arguments, and we let the function know you have to perform your operation with the help of these said things\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The same way, when invoking a system call, we must pass arguments to it"),(0,i.kt)("li",{parentName:"ul"},"We pass arguments by putting them into General Purpose Registers, and if there are too many arguments to be passed, we pass a pointer to the block of structure containing the arguments."),(0,i.kt)("li",{parentName:"ul"},"In case we're using some sort of abstraction (such as that of ",(0,i.kt)("inlineCode",{parentName:"li"},"libc"),"), the arguments are taken in from the user, stored in the Usermode Stack, and at the time of invocation, they're transferred to the System Call Handler's stack in the Kernel Memory space.")),(0,i.kt)("h2",{id:"system-call-wrappers"},"System Call Wrappers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To abstract away the technical complexities, wrappers are provided to simplify their invocation of system calls."),(0,i.kt)("li",{parentName:"ul"},"They help in preparing arguments, putting them at the right places at the right time so that they can be passed down to the Kernel, doing error-checking on them, fetching the result of the system calls and returning them to the application."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Example"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"libc"),", Windows subsystem DLL etc."),(0,i.kt)("li",{parentName:"ul"},"For example, in C, we use the ",(0,i.kt)("inlineCode",{parentName:"li"},"stdio")," Standard I/O library, and there's this function we uses ",(0,i.kt)("inlineCode",{parentName:"li"},"printf()")," to print something to the screen, the ",(0,i.kt)("inlineCode",{parentName:"li"},"write()")," system call happens behind the scenes.")),(0,i.kt)("h2",{id:"system-calls-behind-the-scenes"},"System Calls Behind The Scenes"),(0,i.kt)("h3",{id:"invoking-system-calls"},"Invoking System Calls"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"There must be some mechanism in place to let the Kernel know we wish to invoke a system call."),(0,i.kt)("li",{parentName:"ul"},"There are two mechanisms in place",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Trap Instructions - on x86 ISA, the trap is ",(0,i.kt)("inlineCode",{parentName:"li"},"int 0x80")," and for returning back ",(0,i.kt)("inlineCode",{parentName:"li"},"iret"),")"),(0,i.kt)("li",{parentName:"ul"},"Fast System Calls - ",(0,i.kt)("inlineCode",{parentName:"li"},"sysenter")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sysexit")," on x86 ISA and ",(0,i.kt)("inlineCode",{parentName:"li"},"syscall")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sysret")," for x86-64 ISA"))),(0,i.kt)("li",{parentName:"ul"},"The end goal of both the mechanisms is to make the execution flow jump to where the System Call Handler resides in the Kernel Memory Space.")),(0,i.kt)("h3",{id:"what-actually-happens"},"What Actually Happens?"),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"What Actually Happens",src:n(6141).Z,width:"448",height:"430"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We pass the system call number as an argument and some other arguments to, by placing them in registers or some other parameter passing techniques."),(0,i.kt)("li",{parentName:"ul"},"We trigger the System Call using some mechanism (discussed above)"),(0,i.kt)("li",{parentName:"ul"},"The context of the currently executing process is saved"),(0,i.kt)("li",{parentName:"ul"},"CPU switches to the Ring 0 execution mode"),(0,i.kt)("li",{parentName:"ul"},"Execution flow jumps from the usermode program memory space to where the System Call Handler lies (Kernel Entry Point we call it) in the Kernel Memory Space."),(0,i.kt)("li",{parentName:"ul"},"The System Call Handler does error checking and stuff, and then finally invokes the System Call based on the System Call Table number and other data which we passed down to it as arguments. It checks the System Call table to find the right system call based on the system call number ",(0,i.kt)("inlineCode",{parentName:"li"},"systemCallTableArray[systemcallNumber]")),(0,i.kt)("li",{parentName:"ul"},"The privileged operation take places"),(0,i.kt)("li",{parentName:"ul"},"The return values are placed in registers for the application to use and process context is restored"),(0,i.kt)("li",{parentName:"ul"},"CPU switches back to Ring 3 execution mode by the help of ",(0,i.kt)("inlineCode",{parentName:"li"},"sysexit"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sysret"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"iret")," instructions and the execution flow jumps to the program usermode address space"),(0,i.kt)("li",{parentName:"ul"},"Life goes on.")),(0,i.kt)("h2",{id:"triggering-system-calls"},"Triggering System Calls"),(0,i.kt)("p",null,"We will understand more about how System Calls are invoked"),(0,i.kt)("h3",{id:"the-trap-mechanism---legacy-method"},"The Trap Mechanism - Legacy Method"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Trap Instruction is an exception in the user process where the instruction can't be restarted, on the other hand a Fault is an exception where the instruction can be restarted"),(0,i.kt)("li",{parentName:"ul"},"Trap Instructions is one of the methods by which usermode applications can trigger Kernel mode other than the sysenter/ syscall mechanism."),(0,i.kt)("li",{parentName:"ul"},"For x86, the trap instruction is 0x80, and its set that way as a Interrupt Descriptor Table (IDT) entry during Kernel initialisation by the trap_init() function")),(0,i.kt)("h3",{id:"fast-system-call-mechanism"},"Fast System Call Mechanism"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This mechanism is much faster and reliable than the legacy Trap Instruction method and is optimised to give maximum performance during the ring transition but its more technically complicated and requires better coordination b/w the glibc and the kernel."),(0,i.kt)("li",{parentName:"ul"},"A pair of instructions are used for transitioning and exiting from Kernel mode, sysenter and sysexit (32-bit systems) and syscall and sysret (for 64 bit systems)")))}h.isMDXComponent=!0},6141:function(e,t,n){t.Z=n.p+"assets/images/syscall-operation-d5b2810170dd543797b1591d87e7f67e.png"},5980:function(e,t,n){t.Z=n.p+"assets/images/syscall-table-e5c1751538babc953f6b7e906e81b97a.png"}}]);