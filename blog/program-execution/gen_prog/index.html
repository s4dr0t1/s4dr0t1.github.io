<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generation of Programming Languages | s4dr0t1</title>
<meta name=keywords content><meta name=description content="Understanding different generations of programming languages"><meta name=author content="s4dr0t1"><link rel=canonical href=https://s4dr0t1.github.io/blog/program-execution/gen_prog/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://s4dr0t1.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s4dr0t1.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s4dr0t1.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s4dr0t1.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s4dr0t1.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://s4dr0t1.github.io/blog/program-execution/gen_prog/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://s4dr0t1.github.io/blog/program-execution/gen_prog/"><meta property="og:site_name" content="s4dr0t1"><meta property="og:title" content="Generation of Programming Languages"><meta property="og:description" content="Understanding different generations of programming languages"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-08-18T23:12:29+05:30"><meta property="article:modified_time" content="2023-08-19T00:28:43+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generation of Programming Languages"><meta name=twitter:description content="Understanding different generations of programming languages"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://s4dr0t1.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Generation of Programming Languages","item":"https://s4dr0t1.github.io/blog/program-execution/gen_prog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generation of Programming Languages","name":"Generation of Programming Languages","description":"Understanding different generations of programming languages","keywords":[],"articleBody":"When learning about computer hardware and digital electronics, we learn about the CPU and how it fetches, decodes, and executes instructions with the help of the fetch-decode-execute cycle, but where actually do those instructions come from? They need to be written, which is done by something called programming. (If you have no fucking clue what the fetch-decode-execute cycle is, look up Stored Program Execution on the Internet, or maybe I’ll write about it on my blog soon?)\nThere are all sorts of programming languages out there that can be categorized into generations, and their generation indicates how close they are to the hardware.\nThe first-generation - Machine Language To speak directly with electronic hardware, we need to send electric signals (0 and 1), and these two signals are the only things that the microprocessor understands. Machine language consists of instructions made up only of 0s and 1s.\nWhy only 0s and 1s as electric signals at the lowest level?\nHaving anything more will make the digital design harder and more confusing to implement as we’ll have to specify ranges. Example: 0v = 0, 1v = 1, 2v = 2 Sometimes due to interference or lack of power, we may not get proper results, say we wanted to give 2 as a signal but due to low power supply, we could only have 1v, thus the machine will get 1 as a signal, thereby confusing it and causing unnecessary drama. The 0 and 1 system is already good.\nAn instruction is a command we give to a computer system to instruct it to do something,\nFormat of machine-level language instruction:\nOpcode (Operation Code): Instruct the computer on what functions are to be performed Operands: Instruct the computer where to find/ store data for the desired operation 0101 00111 11110 | \\ \\ ┌────┐ ┌─────┐ ┌─────┐ │0101│ │00111│ │11110│ └────┘ └─────┘ └─────┘ Opcode A B Operands Advantages\nFaster (\u003ehigh level) because of the lack of translation overhead Extremely granular control on hardware Disadvantages\nThe language is very much dependent on the hardware. Lack of portability is a big problem here Since the language is all 0s and 1s, it makes it much harder to learn It takes time to write code using machine language (it’s fricking obvious) Less efficient (of course! because it’s very difficult to code in) The second-generation - Assembly Language Since writing machine code was extremely hard, processor-dependent, and time-consuming, something was needed which was closer to the way humans think.\nAssembly is the symbolic representation of binary instructions in which mnemonics are used instead of binary instructions. Mnemonics are the mappings for the binary machine codes so as to enable faster writing and debugging of code. The instruction:machineCode mapping is maintained by the ISA (Instruction Set Architecture)\nExample: in the 8085 architecture, A register is the mapping for 111, and ADD is the mapping for 10000, when we assemble our code for say ADD A it would get translated to (10000)(111)\nSince abstraction is involved, mnemonics can’t be directly understood by a processor, and an assembler is needed to translate Assembly Code into its machine equivalent.\n;; Format of an assembly instruction: label: mov A, B ;;In this scenario, label will have the value of the address where this instruction is loaded in memory and can be used to reference it. Advantages\nRelatively easier to understand and use Less error-prone than directly writing machine language Faster (\u003ehigh level) (still) control of hardware Disadvantages\nNot cross-platform, and very specific to the processor family such as Intel has IA-32 and IA-64 Harder to learn Slow development time Less efficient No standardization The third Generation - High-Level Languages Even though assembly made it easier for programmers to code, it was too procedural in nature viz. closer to the way a processor executes instructions and not how a normal person would think. This is why we added more abstraction and invented High-Level languages\nHLLs allow a program to think in a more natural language than a set of imperative statements that will be executed by the microprocessor.\nExample: C, Java, COBOL, FORTRAN, C++, Perl, SQL, JavaScript etc\nAdvantages\nOffers ease of development (easy to read and code in, easy debugging, and easy maintenance) Machine-independent and compilers/ assemblers will handle the translation. Lots of hardware operations managed by the language itself No need to know computer architecture in detail Less time taken to develop the program Disadvantages\nLess flexible than low level All the additional steps increase the execution time of an application ","wordCount":"750","inLanguage":"en","datePublished":"2023-08-18T23:12:29+05:30","dateModified":"2023-08-19T00:28:43+05:30","author":{"@type":"Person","name":"s4dr0t1"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://s4dr0t1.github.io/blog/program-execution/gen_prog/"},"publisher":{"@type":"Organization","name":"s4dr0t1","logo":{"@type":"ImageObject","url":"https://s4dr0t1.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://s4dr0t1.github.io/ accesskey=h title="s4dr0t1 (Alt + H)">s4dr0t1</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://s4dr0t1.github.io/about/ title=About><span>About</span></a></li><li><a href=https://s4dr0t1.github.io/archives title=Blog><span>Blog</span></a></li><li><a href=https://s4dr0t1.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Generation of Programming Languages</h1><div class=post-description>Understanding different generations of programming languages</div><div class=post-meta><span title='2023-08-18 23:12:29 +0530 +0530'>August 18, 2023</span>&nbsp;·&nbsp;750 words&nbsp;·&nbsp;s4dr0t1</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#the-first-generation---machine-language>The first-generation - Machine Language</a></li><li><a href=#the-second-generation---assembly-language>The second-generation - Assembly Language</a></li><li><a href=#the-third-generation---high-level-languages>The third Generation - High-Level Languages</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>When learning about computer hardware and digital electronics, we learn about the CPU and how it fetches, decodes, and executes instructions with the help of the fetch-decode-execute cycle, but where actually do those instructions come from?
They need to be written, which is done by something called programming. (If you have no fucking clue what the fetch-decode-execute cycle is, look up <strong>Stored Program Execution</strong> on the Internet, or maybe I&rsquo;ll write about it on my blog soon?)</p><p>There are all sorts of programming languages out there that can be categorized into generations, and their generation indicates how close they are to the hardware.</p><h3 id=the-first-generation---machine-language>The first-generation - Machine Language<a hidden class=anchor aria-hidden=true href=#the-first-generation---machine-language>#</a></h3><p>To speak directly with electronic hardware, we need to send electric signals (0 and 1), and these two signals are the only things that the microprocessor understands. Machine language consists of instructions made up only of 0s and 1s.</p><blockquote><p><strong>Why only 0s and 1s as electric signals at the lowest level?</strong></p><p>Having anything more will make the digital design harder and more confusing to implement as we&rsquo;ll have to specify ranges.
Example: 0v = 0, 1v = 1, 2v = 2
Sometimes due to interference or lack of power, we may not get proper results, say we wanted to give 2 as a signal but due to low power supply, we could only have 1v, thus the machine will get 1 as a signal, thereby confusing it and causing unnecessary drama. The 0 and 1 system is already good.</p></blockquote><p>An instruction is a command we give to a computer system to instruct it to do something,</p><p>Format of machine-level language instruction:</p><ul><li><strong>Opcode</strong> (Operation Code): Instruct the computer on what functions are to be performed</li><li><strong>Operands</strong>: Instruct the computer where to find/ store data for the desired operation</li></ul><pre tabindex=0><code>0101 00111 11110
  |     \       \
┌────┐   ┌─────┐ ┌─────┐
│0101│   │00111│ │11110│
└────┘   └─────┘ └─────┘
Opcode     A        B
            Operands
</code></pre><blockquote><p><strong>Advantages</strong></p><ul><li>Faster (>high level) because of the lack of translation overhead</li><li>Extremely granular control on hardware</li></ul></blockquote><blockquote><p><strong>Disadvantages</strong></p><ul><li>The language is very much dependent on the hardware. Lack of portability is a big problem here</li><li>Since the language is all 0s and 1s, it makes it much harder to learn</li><li>It takes time to write code using machine language (it&rsquo;s fricking obvious)</li><li>Less efficient (of course! because it&rsquo;s very difficult to code in)</li></ul></blockquote><h3 id=the-second-generation---assembly-language>The second-generation - Assembly Language<a hidden class=anchor aria-hidden=true href=#the-second-generation---assembly-language>#</a></h3><p>Since writing machine code was extremely hard, processor-dependent, and time-consuming, something was needed which was closer to the way humans think.</p><p>Assembly is the symbolic representation of binary instructions in which mnemonics are used instead of binary instructions.
Mnemonics are the mappings for the binary machine codes so as to enable faster writing and debugging of code. The <code>instruction:machineCode</code> mapping is maintained by the ISA (Instruction Set Architecture)</p><p><strong>Example</strong>: in the 8085 architecture, A register is the mapping for 111, and ADD is the mapping for 10000, when we assemble our code for say ADD A it would get translated to (10000)(111)</p><p>Since abstraction is involved, mnemonics can&rsquo;t be directly understood by a processor, and an assembler is needed to translate Assembly Code into its machine equivalent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#75715e>;; Format of an assembly instruction:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>label: <span style=color:#a6e22e>mov</span> A, B
</span></span><span style=display:flex><span><span style=color:#75715e>;;In this scenario, label will have the value of the address where this instruction is loaded in memory and can be used to reference it.</span>
</span></span></code></pre></div><blockquote><p><strong>Advantages</strong></p><ul><li>Relatively easier to understand and use</li><li>Less error-prone than directly writing machine language</li><li>Faster (>high level)</li><li>(still) control of hardware</li></ul></blockquote><blockquote><p><strong>Disadvantages</strong></p><ul><li>Not cross-platform, and very specific to the processor family such as Intel has IA-32 and IA-64</li><li>Harder to learn</li><li>Slow development time</li><li>Less efficient</li><li>No standardization</li></ul></blockquote><h3 id=the-third-generation---high-level-languages>The third Generation - High-Level Languages<a hidden class=anchor aria-hidden=true href=#the-third-generation---high-level-languages>#</a></h3><p>Even though assembly made it easier for programmers to code, it was too procedural in nature viz. closer to the way a processor executes instructions and not how a normal person would think. This is why we added more abstraction and invented High-Level languages</p><p>HLLs allow a program to think in a more natural language than a set of imperative statements that will be executed by the microprocessor.</p><p><strong>Example</strong>: C, Java, COBOL, FORTRAN, C++, Perl, SQL, JavaScript etc</p><blockquote><p><strong>Advantages</strong></p><ul><li>Offers ease of development (easy to read and code in, easy debugging, and easy maintenance)</li><li>Machine-independent and compilers/ assemblers will handle the translation.</li><li>Lots of hardware operations managed by the language itself</li><li>No need to know computer architecture in detail</li><li>Less time taken to develop the program</li></ul></blockquote><blockquote><p><strong>Disadvantages</strong></p><ul><li>Less flexible than low level</li><li>All the additional steps increase the execution time of an application</li></ul></blockquote></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://s4dr0t1.github.io/>s4dr0t1</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>